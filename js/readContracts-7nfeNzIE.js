import{$ as P,h as R}from"../index-JdCxlw3t.js";import{g as z,b as v,d as x,h as $,m as O,i as _,R as B,j as T,C as q}from"./call-DYnlgnIr.js";import{a as M,r as Z}from"./toFixed-C6TjCq0V.js";async function G(e,u){var j;const{allowFailure:i=!0,batchSize:g,blockNumber:d,blockTag:C,multicallAddress:b,stateOverride:A}=u,a=u.contracts,h=g??(typeof((j=e.batch)==null?void 0:j.multicall)=="object"&&e.batch.multicall.batchSize||1024);let c=b;if(!c){if(!e.chain)throw new Error("client chain not configured. multicallAddress is required.");c=z({blockNumber:d,chain:e.chain,contract:"multicall3"})}const s=[[]];let t=0,r=0;for(let n=0;n<a.length;n++){const{abi:f,address:p,args:l,functionName:y}=a[n];try{const m=v({abi:f,args:l,functionName:y});r+=(m.length-2)/2,h>0&&r>h&&s[t].length>0&&(t++,r=(m.length-2)/2,s[t]=[]),s[t]=[...s[t],{allowFailure:!0,callData:m,target:p}]}catch(m){const I=x(m,{abi:f,address:p,args:l,docsPath:"/docs/contract/multicall",functionName:y});if(!i)throw I;s[t]=[...s[t],{allowFailure:!0,callData:"0x",target:p}]}}const o=await Promise.allSettled(s.map(n=>$(e,M,"readContract")({abi:O,address:c,args:[n],blockNumber:d,blockTag:C,functionName:"aggregate3",stateOverride:A}))),w=[];for(let n=0;n<o.length;n++){const f=o[n];if(f.status==="rejected"){if(!i)throw f.reason;for(let l=0;l<s[n].length;l++)w.push({status:"failure",error:f.reason,result:void 0});continue}const p=f.value;for(let l=0;l<p.length;l++){const{returnData:y,success:m}=p[l],{callData:I}=s[n][l],{abi:k,address:N,functionName:D,args:E}=a[w.length];try{if(I==="0x")throw new _;if(!m)throw new B({data:y});const F=T({abi:k,args:E,data:y,functionName:D});w.push(i?{result:F,status:"success"}:F)}catch(F){const S=x(F,{abi:k,address:N,args:E,docsPath:"/docs/contract/multicall",functionName:D});if(!i)throw S;w.push({error:S,result:void 0,status:"failure"})}}}if(w.length!==a.length)throw new P("multicall results mismatch");return w}async function H(e,u){const{allowFailure:i=!0,chainId:g,contracts:d,...C}=u,b=e.getClient({chainId:g});return R(b,G,"multicall")({allowFailure:i,contracts:d,...C})}async function Q(e,u){var A;const{allowFailure:i=!0,blockNumber:g,blockTag:d,...C}=u,b=u.contracts;try{const a={};for(const[t,r]of b.entries()){const o=r.chainId??e.state.chainId;a[o]||(a[o]=[]),(A=a[o])==null||A.push({contract:r,index:t})}const h=()=>Object.entries(a).map(([t,r])=>H(e,{...C,allowFailure:i,blockNumber:g,blockTag:d,chainId:Number.parseInt(t),contracts:r.map(({contract:o})=>o)})),c=(await Promise.all(h())).flat(),s=Object.values(a).flatMap(t=>t.map(({index:r})=>r));return c.reduce((t,r,o)=>(t&&(t[s[o]]=r),t),[])}catch(a){if(a instanceof q)throw a;const h=()=>b.map(c=>Z(e,{...c,blockNumber:g,blockTag:d}));return i?(await Promise.allSettled(h())).map(c=>c.status==="fulfilled"?{result:c.value,status:"success"}:{error:c.reason,result:void 0,status:"failure"}):await Promise.all(h())}}export{Q as r};
